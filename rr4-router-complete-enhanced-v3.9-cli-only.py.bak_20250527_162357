#!/usr/bin/env python3
"""
Phased Audit Tool

This tool performs a 5-phase security audit on network devices.
Phases:
1. Connectivity Verification
2. Authentication Testing
3. Configuration Audit
4. Risk Assessment
5. Reporting and Recommendations
"""

import sqlite3
import datetime
import json
import uuid
import os
import getpass
import base64
import subprocess # Added for Phase 1
import re # Added for Phase 1 RTT parsing
from netmiko import ConnectHandler
from netmiko.exceptions import NetmikoTimeoutException, NetmikoAuthenticationException, SSHException
from flask import Flask, render_template, jsonify, request, Response
from flask_socketio import SocketIO, emit
from functools import wraps
from collections import deque, defaultdict # For credential history, error counts, and potentially other uses
from typing import Dict, Any, List, Optional # Ensure List and Optional are imported
import logging # <--- Add this import

# Import cryptography libraries for secure credential management
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

# Import colorama for colored terminal output if available
try:
    from colorama import Fore, Style, init
    init(autoreset=True)
    colorama_available = True
except ImportError:
    # Create mock Fore and Style if colorama not available
    class MockColor:
        def __getattr__(self, name):
            return ""
    Fore = Style = MockColor()
    colorama_available = False


# Global list for strings to redact, can be populated by config later
sensitive_strings_to_redact: List[str] = []

def sanitize_log_message(msg: str, custom_sensitive_strings: Optional[List[str]] = None) -> str:
    """Sanitizes a message by redacting sensitive information."""
    if not isinstance(msg, str):
        # If the message isn't a string, try to convert it, or return a placeholder
        try:
            msg = str(msg)
        except Exception:
            return "[Non-string message content]"

    # Redact patterns like username=value, password=value, secret=value
    # Corrected regex: moved ')' outside of character class '[]'
    msg = re.sub(r'(username|password|secret)=(?:["\']?)([^,\s"\']+)(?:["\']?)', r'\1=****', msg, flags=re.IGNORECASE)

    # Redact common sensitive keywords followed by their values
    # Example: "Password: mysecretpassword", "API_KEY = abcdef12345"
    msg = re.sub(r'(username|password|secret)[:\s=]+[^,\s]+', r'\1=****', msg, flags=re.IGNORECASE)

    # Redact IP addresses
    msg = re.sub(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', '***.***.***.***', msg)

    # Redact SSH connection strings - mask username
    msg = re.sub(r'(\w+)@(\d+\.\d+\.\d+\.\d+)', '****@\\2', msg)

    # Function parameters
    msg = re.sub(r'(username|password|secret)=(?:["\']?)([^,\s"\']+)(?:["\']?)', r'\1=****', msg, flags=re.IGNORECASE)
    
    # Additional sensitive patterns from global list
    for sensitive in sensitive_strings_to_redact:
        if sensitive and len(sensitive) > 0:
            msg = msg.replace(sensitive, '####')
    
    return msg

def log_cli_message(msg: str, level: str = "INFO", is_sensitive: bool = False, end="\n"):
    """Logs a message to the CLI with timestamp, level, and color coding, and to the log file."""
    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    processed_msg = str(msg)
    
    # Always sanitize for a security tool to be safe, or use is_sensitive flag
    # For now, let's always sanitize to be cautious.
    processed_msg_for_file = sanitize_log_message(processed_msg) # Sanitize for file log
    processed_msg_for_console = sanitize_log_message(processed_msg) # Sanitize separately for console if needed, or use the same

    level_upper = level.upper()
    color_prefix = ""
    color_suffix = ""

    # Console logging (existing functionality)
    if colorama_available:
        if level_upper == "ERROR":
            color_prefix = Fore.RED
        elif level_upper == "WARNING":
            color_prefix = Fore.YELLOW
        elif level_upper == "SUCCESS":
            color_prefix = Fore.GREEN
        elif level_upper == "DEBUG":
            color_prefix = Fore.CYAN
        elif level_upper == "INFO":
            color_prefix = Fore.BLUE # Or Fore.WHITE / default
        elif level_upper == "TRACE": # Added TRACE level
            color_prefix = Fore.MAGENTA
        color_suffix = Style.RESET_ALL
    print(f"{color_prefix}[{timestamp}] [{level_upper}] {processed_msg_for_console}{color_suffix}", end=end)

    # File logging using Python's logging module
    # Get a logger instance (e.g., using the current module's name)
    logger = logging.getLogger(__name__) # Or a more specific logger name if desired
    
    log_level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL,
        "SUCCESS": logging.INFO, # logging module doesn't have SUCCESS, map to INFO
        "TRACE": logging.DEBUG # Map TRACE to DEBUG for file logging
    }
    
    # Get the corresponding logging level, default to INFO if not found
    numeric_log_level = log_level_map.get(level_upper, logging.INFO)
    
    # Log the message to the file
    # The file logger is already configured with its own timestamp and format by setup_logging
    logger.log(numeric_log_level, processed_msg_for_file)


@error_handler(ErrorCategory.SYSTEM)
def log_raw_trace(msg: str, command_type: str = "TRACE", device: str = None, **kwargs):
    """
    Raw trace logging for detailed debugging and jump host command tracking.
    Captures detailed operations with millisecond timestamps.
    """
    # Create detailed timestamp
    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]  # Include milliseconds
    
    # Build detailed trace message
    if device:
        trace_msg = f"[{command_type}] [{device}] {msg}" # Timestamp will be added by log_cli_message
    else:
        trace_msg = f"[{command_type}] {msg}" # Timestamp will be added by log_cli_message

    # Log using the existing log_cli_message, providing the raw timestamp within the message part
    # or let log_cli_message handle its own timestamping. For consistency, let log_cli_message do it.
    # Re-evaluating: The raw trace wants its own ms timestamp. Let's pass the full pre-formatted msg.
    
    # Let's keep the original raw trace format which includes its own ms timestamp for precision.
    # We'll call log_cli_message with the fully formed trace_msg and a specific level.
    full_trace_message_with_ms_timestamp = f"[{timestamp}] {trace_msg}"
    
    # We can use the command_type as the level for log_cli_message
    # Ensure command_type is uppercase to match level handling in log_cli_message
    log_cli_message(full_trace_message_with_ms_timestamp, level=command_type.upper(), **kwargs)

# ====================================================================
# ADVANCED ERROR HANDLING
# ====================================================================

class ErrorCategory:
    """Advanced error categorization"""
    NETWORK = "network"
    AUTHENTICATION = "authentication"
    CONFIGURATION = "configuration"
    SYSTEM = "system"
    USER_INPUT = "user_input"
    PERFORMANCE = "performance"
    JUMP_HOST = "jump_host"
    DEVICE_CONNECTION = "device_connection"
    DEVICE_INTERACTION = "device_interaction"

class AdvancedErrorHandler:
    """Advanced error handling with recovery mechanisms"""
    
    def __init__(self):
        self.error_history = deque(maxlen=100)
        self.error_counts = defaultdict(int)
        self.recovery_strategies = {
            ErrorCategory.NETWORK: self._recover_network_error,
            ErrorCategory.AUTHENTICATION: self._recover_auth_error,
            ErrorCategory.CONFIGURATION: self._recover_config_error,
            ErrorCategory.SYSTEM: self._recover_system_error,
            ErrorCategory.JUMP_HOST: self._recover_jump_host_error,
            ErrorCategory.DEVICE_CONNECTION: self._recover_device_connection_error,
            ErrorCategory.DEVICE_INTERACTION: self._recover_device_interaction_error,
        }
    
    def handle_error(self, error: Exception, category: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Handle error with categorization and recovery"""
        error_info = {
            'timestamp': datetime.now().isoformat(),
            'category': category,
            'error_type': type(error).__name__,
            'message': str(error),
            'context': context or {},
            'recovery_attempted': False,
            'recovery_successful': False
        }
        
        self.error_history.append(error_info)
        self.error_counts[category] += 1
        
        if category in self.recovery_strategies:
            try:
                recovery_result = self.recovery_strategies[category](error, context)
                error_info['recovery_attempted'] = True
                error_info['recovery_successful'] = recovery_result.get('success', False)
                error_info['recovery_details'] = recovery_result
            except Exception as recovery_error:
                error_info['recovery_error'] = str(recovery_error)
        
        error_info['user_message'] = self._generate_user_message(error_info)
        
        return error_info
    
    def _recover_network_error(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        return {
            'success': False,
            'strategy': 'retry_with_backoff',
            'recommendation': 'Check network connectivity and retry',
            'retry_count': context.get('retry_count', 0) + 1 if context else 1
        }
    
    def _recover_auth_error(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        return {
            'success': False,
            'strategy': 'credential_validation',
            'recommendation': 'Verify credentials and try again',
            'requires_user_action': True
        }
    
    def _recover_config_error(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        return {
            'success': False,
            'strategy': 'default_fallback',
            'recommendation': 'Check configuration settings',
            'fallback_applied': True
        }
    
    def _recover_system_error(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        return {
            'success': False,
            'strategy': 'resource_cleanup',
            'recommendation': 'System resources may be limited',
            'cleanup_performed': True
        }
    
    def _recover_jump_host_error(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        return {
            'success': False,
            'strategy': 'jump_host_retry',
            'recommendation': 'Check jump host connectivity and retry',
            'retry_count': context.get('retry_count', 0) + 1 if context else 1
        }
    
    def _recover_device_connection_error(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        return {
            'success': False,
            'strategy': 'device_connection_retry',
            'recommendation': 'Check device connectivity and retry',
            'retry_count': context.get('retry_count', 0) + 1 if context else 1
        }
    
    def _recover_device_interaction_error(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        return {
            'success': False,
            'strategy': 'device_interaction_retry',
            'recommendation': 'Check device interaction and retry',
            'retry_count': context.get('retry_count', 0) + 1 if context else 1
        }
    
    def _generate_user_message(self, error_info: Dict[str, Any]) -> str:
        category = error_info['category']
        error_type = error_info['error_type']
        message = error_info['message']
        
        user_msg = f"Error ({category} - {error_type}): {message}"
        if error_info.get('recovery_attempted'):
            if error_info.get('recovery_successful'):
                user_msg += " | Recovery successful."
            else:
                user_msg += " | Recovery attempted but failed."
                if error_info.get('recovery_details', {}).get('recommendation'):
                    user_msg += f" Recommendation: {error_info['recovery_details']['recommendation']}"
        return user_msg

error_handler_instance = AdvancedErrorHandler()

def error_handler(category: str = ErrorCategory.SYSTEM):
    """Decorator for advanced error handling"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                # start_time = time.time() # Performance monitoring - commented out
                result = func(*args, **kwargs)
                # duration = time.time() - start_time # Performance monitoring - commented out
                # performance_monitor.record_metric('response_times', duration) # Performance monitoring - commented out
                # performance_monitor.metrics['requests_processed'] += 1 # Performance monitoring - commented out
                return result
            except Exception as e:
                context = {
                    'function_name': func.__name__,
                    'args_count': len(args),
                    'kwargs_keys': list(kwargs.keys())
                }
                error_info = error_handler_instance.handle_error(e, category, context)
                # performance_monitor.metrics['error_count'] += 1 # Performance monitoring - commented out
                
                # TODO: Integrate with a proper logger or log_to_ui_and_console if available
                log_cli_message(f"❌ {error_info['user_message']}", level="ERROR") # Use new CLI logger
                raise
        return wrapper
    return decorator

class CredentialManager:
    """
    Handles encryption and decryption of sensitive credentials
    Uses Fernet symmetric encryption with a key derived from a master password
    """
    
    def __init__(self, master_password=None):
        """Initialize credential manager with optional master password"""
        self.salt = None
        self.key = None
        self.cipher_suite = None
        self.salt_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), '.salt')
        
        # Initialize with master password if provided
        if master_password:
            self.initialize(master_password)
    
    def initialize(self, master_password):
        """
        Initialize the encryption with a master password
        Will create a new salt if none exists or load existing one
        """
        if os.path.exists(self.salt_file):
            # Load existing salt
            with open(self.salt_file, 'rb') as f:
                self.salt = f.read()
        else:
            # Generate new salt
            self.salt = os.urandom(16)
            # Save salt to file with secure permissions
            with open(self.salt_file, 'wb') as f:
                f.write(self.salt)
            os.chmod(self.salt_file, 0o600)  # Only user can read/write
        
        # Generate key from password
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=self.salt,
            iterations=100000,
        )
        
        # Derive the key from the password
        key = base64.urlsafe_b64encode(kdf.derive(master_password.encode()))
        self.cipher_suite = Fernet(key)
    
    def encrypt(self, plaintext):
        """
        Encrypt a string and return a base64-encoded encrypted value
        """
        if not self.cipher_suite:
            raise ValueError("Credential manager not initialized with a master password")
            
        if not plaintext:
            return ""
            
        return self.cipher_suite.encrypt(plaintext.encode()).decode()
    
    def decrypt(self, encrypted_text):
        """
        Decrypt a base64-encoded encrypted value and return the plaintext
        """
        if not self.cipher_suite:
            raise ValueError("Credential manager not initialized with a master password")
            
        if not encrypted_text:
            return ""
            
        try:
            return self.cipher_suite.decrypt(encrypted_text.encode()).decode()
        except Exception as e:
            raise ValueError(f"Decryption failed: {e}")
    
    def hash_password(self, password, salt=None):
        """
        Generate a secure hash of a password with an optional salt
        Returns (hash, salt) tuple
        """
        if not salt:
            salt = os.urandom(16)
            
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        
        password_hash = kdf.derive(password.encode())
        return base64.b64encode(password_hash).decode(), base64.b64encode(salt).decode()
    
    def verify_password(self, password, stored_hash, salt):
        """
        Verify a password against a stored hash and salt
        """
        password_hash, _ = self.hash_password(
            password, 
            base64.b64decode(salt)
        )
        return password_hash == stored_hash


def prompt_for_master_password(confirm=True):
    """
    Prompt user for a secure master password with confirmation
    Returns the entered password
    """
    print(f"\n{Fore.YELLOW}{'='*60}{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}🔐 SECURITY SETUP - MASTER PASSWORD REQUIRED 🔐{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}This password will be used to encrypt all sensitive information.{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}It will not be stored anywhere - please remember it!{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}{'='*60}{Style.RESET_ALL}")
    
    while True:
        master_password = getpass.getpass(f"\n{Fore.CYAN}Enter your master password: {Style.RESET_ALL}")
        
        if not master_password:
            print(f"{Fore.RED}Password cannot be empty. Please try again.{Style.RESET_ALL}")
            continue
            
        # Skip confirmation if not required
        if not confirm:
            return master_password
            
        confirm_password = getpass.getpass(f"{Fore.CYAN}Confirm your master password: {Style.RESET_ALL}")
        
        if master_password != confirm_password:
            print(f"{Fore.RED}Passwords do not match. Please try again.{Style.RESET_ALL}")
        else:
            break
    
    print(f"\n{Fore.GREEN}✅ Master password successfully set{Style.RESET_ALL}")
    return master_password


DATABASE_NAME = 'phased_audit_results.sqlite'

# Initialize Flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = 'phased_audit_secret_key'
app.config['PORT'] = 5012
socketio = SocketIO(app)

def initialize_database():
    """Initializes the SQLite database and creates the audit_phase_results table if it doesn't exist."""
    conn = sqlite3.connect(DATABASE_NAME)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS audit_phase_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            audit_run_id TEXT NOT NULL,
            router_hostname TEXT NOT NULL,
            router_ip TEXT,
            phase_number INTEGER NOT NULL,
            phase_name TEXT NOT NULL,
            status TEXT NOT NULL, 
            summary TEXT,
            details TEXT, 
            error_message TEXT,
            start_time DATETIME,
            end_time DATETIME
        )
    ''')
    conn.commit()
    conn.close()
    print(f"Database {DATABASE_NAME} initialized/verified.")

def log_phase_result(audit_run_id, router_hostname, router_ip, phase_number, phase_name, status, summary="", details=None, error_message="", start_time=None, end_time=None):
    """Logs the result of an audit phase to the database."""
    conn = sqlite3.connect(DATABASE_NAME)
    cursor = conn.cursor()
    
    current_time = datetime.datetime.now()
    if start_time is None:
        start_time = current_time
    if end_time is None and status not in ["IN_PROGRESS"]:
        end_time = current_time

    details_json = json.dumps(details) if details is not None else None

    cursor.execute('''
        INSERT INTO audit_phase_results 
            (audit_run_id, router_hostname, router_ip, phase_number, phase_name, status, summary, details, error_message, start_time, end_time)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', (audit_run_id, router_hostname, router_ip, phase_number, phase_name, status, summary, details_json, error_message, start_time, end_time))
    conn.commit()
    conn.close()

# --- Phase 1: Helper Function ---
def _ping_device(ip_address):
    """Pings an IP address and returns status, summary, and details."""
    try:
        # For Linux/macOS, using -c 4 for 4 pings, -W 1 for 1-second timeout per ping.
        # For Windows, it would be -n 4 -w 1000.
        # Adjust command based on the USER's OS if known, otherwise default to Linux-like.
        command = ['ping', '-c', '4', '-W', '1', ip_address]
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        stdout, stderr = process.communicate(timeout=10) # 10-second overall timeout for the subprocess

        if process.returncode == 0:
            status = "SUCCESS"
            summary = f"Successfully pinged {ip_address}."
            # Try to extract RTT avg from output (example for Linux ping)
            rtt_match = re.search(r'rtt min/avg/max/mdev = [\d\.]+/([\d\.]+)/[\d\.]+/([\d\.]+) ms', stdout)
            if rtt_match:
                details = {"rtt_avg_ms": rtt_match.group(1), "output": stdout}
            else:
                details = {"output": stdout} # Include full output if RTT parsing fails
            error = ""
        elif process.returncode == 1: # Host unreachable or other non-zero for no reply (common for ping)
            status = "FAILURE"
            summary = f"Ping failed: No reply from {ip_address}."
            details = {"output": stdout, "error_output": stderr}
            error = f"No reply from {ip_address}. Stderr: {stderr.strip()}"
        else: # Other errors
            status = "FAILURE"
            summary = f"Ping failed for {ip_address} with exit code {process.returncode}."
            details = {"output": stdout, "error_output": stderr, "return_code": process.returncode}
            error = f"Ping command error. Stderr: {stderr.strip()} Stdout: {stdout.strip()}"

    except subprocess.TimeoutExpired:
        status = "FAILURE"
        summary = f"Ping timed out for {ip_address}."
        details = None
        error = "Ping command timed out after 10 seconds."
    except FileNotFoundError: # ping command not found
        status = "FAILURE"
        summary = "Ping command not found."
        details = None
        error = "The 'ping' command was not found on the system. Please ensure it is installed and in PATH."
    except Exception as e:
        status = "FAILURE"
        summary = f"An unexpected error occurred during ping: {str(e)}"
        details = None
        error = f"Unexpected ping error: {str(e)}"
    
    return status, summary, details, error

# --- Phase 1: Connectivity Verification ---
def execute_phase1_connectivity(audit_run_id, router_config):
    """Verifies basic network connectivity to the router (e.g., ICMP ping)."""
    hostname = router_config.get('hostname')
    ip_address = router_config.get('ip')
    phase_name = "Connectivity Verification"
    print(f"Starting Phase 1: {phase_name} for {hostname} ({ip_address})")
    start_time = datetime.datetime.now()

    if not ip_address:
        status = "FAILURE"
        summary = "IP address not provided for router."
        details = None
        error = "Missing IP address in router configuration."
    else:
        status, summary, details, error = _ping_device(ip_address)

    log_phase_result(audit_run_id, hostname, ip_address, 1, phase_name, status, summary, details, error, start_time)
    return {"status": status, "details": details, "error": error}

# --- Phase 2: Authentication Testing ---
def execute_phase2_authentication(audit_run_id, router_config, phase1_result, cred_manager=None):
    """Attempts to authenticate to the router using provided credentials."""
    hostname = router_config.get('hostname')
    ip_address = router_config.get('ip')
    phase_name = "Authentication Testing"
    print(f"\n{Fore.BLUE}Starting Phase 2: {phase_name} for {hostname}{Style.RESET_ALL}")
    start_time = datetime.datetime.now()
    net_connect = None # Initialize net_connect

    if phase1_result.get('status') != "SUCCESS":
        status = "SKIPPED"
        summary = "Skipped due to Phase 1 failure (device unreachable)."
        details = None
        error = phase1_result.get('error', "Connectivity failed.")
        log_phase_result(audit_run_id, hostname, ip_address, 2, phase_name, status, summary, details, error, start_time)
        return {"status": status, "details": details, "error": error, "connection": net_connect}

    device_type = router_config.get('device_type', 'cisco_ios') # Default to cisco_ios if not specified
    username = router_config.get('username')
    
    # Securely handle password with credential manager if available
    password = router_config.get('password')
    secret = router_config.get('secret', '') # Optional enable secret
    
    # Check if credentials are encrypted and need decryption
    if cred_manager and password and password.startswith('gAAAAAB'):
        try:
            print(f"{Fore.CYAN}Decrypting router credentials with master password...{Style.RESET_ALL}")
            password = cred_manager.decrypt(password)
            if secret and secret.startswith('gAAAAAB'):
                secret = cred_manager.decrypt(secret)
        except Exception as e:
            print(f"{Fore.RED}Error decrypting credentials: {e}. Using as-is.{Style.RESET_ALL}")
            # Continue with encrypted password as fallback - connection will likely fail

    if not all([ip_address, username, password]):
        status = "FAILURE"
        summary = "Missing required credentials (IP, username, or password) for SSH."
        details = None
        error = "Incomplete router configuration for authentication."
        log_phase_result(audit_run_id, hostname, ip_address, 2, phase_name, status, summary, details, error, start_time)
        return {"status": status, "details": details, "error": error, "connection": net_connect}

    device = {
        'device_type': device_type,
        'host': ip_address,
        'username': username,
        'password': password,
        'secret': secret,
        'port': router_config.get('port', 22), # Default to port 22
        'global_delay_factor': 2, # Adjust as needed
    }

    try:
        print(f"  Attempting SSH to {ip_address} as {username}...")
        net_connect = ConnectHandler(**device)
        status = "SUCCESS"
        summary = f"Successfully authenticated to {ip_address} via SSH."
        details = {"auth_method": "ssh_password", "device_type": device_type}
        error = ""
        # Note: We keep net_connect open for Phase 3
        print(f"  SSH connection successful for {hostname}.")

    except NetmikoAuthenticationException as e:
        status = "FAILURE"
        summary = f"Authentication failed for {ip_address}. Invalid credentials or SSH configuration issue."
        details = {"exception_type": "NetmikoAuthenticationException"}
        error = str(e)
        print(f"  Authentication failed for {hostname}: {error}")
    except NetmikoTimeoutException as e:
        status = "FAILURE"
        summary = f"SSH connection timed out for {ip_address}. Device may be unreachable or SSH service not responding."
        details = {"exception_type": "NetmikoTimeoutException"}
        error = str(e)
        print(f"  SSH timeout for {hostname}: {error}")
    except SSHException as e: # More generic SSH library errors (e.g. no matching key exchange, etc.)
        status = "FAILURE"
        summary = f"An SSH protocol error occurred for {ip_address}."
        details = {"exception_type": "SSHException"}
        error = str(e)
        print(f"  SSH protocol error for {hostname}: {error}")
    except Exception as e:
        status = "FAILURE"
        summary = f"An unexpected error occurred during SSH connection to {ip_address}."
        details = {"exception_type": str(type(e).__name__)}
        error = str(e)
        print(f"  Unexpected SSH error for {hostname}: {error}")

    log_phase_result(audit_run_id, hostname, ip_address, 2, phase_name, status, summary, details, error, start_time)
    # If connection failed, net_connect will be None. If successful, it's the active connection object.
    return {"status": status, "details": details, "error": error, "connection": net_connect}

# --- Phase 3: Configuration Audit ---
def execute_phase3_config_audit(audit_run_id, router_config, phase2_result):
    """Collects device configuration and audits it against predefined policies/rules."""
    hostname = router_config.get('hostname')
    ip_address = router_config.get('ip')
    net_connect = phase2_result.get('connection') # Get connection from Phase 2
    phase_name = "Configuration Audit"
    print(f"Starting Phase 3: {phase_name} for {hostname}")
    start_time = datetime.datetime.now()
    collected_data = {}

    if phase2_result.get('status') != "SUCCESS" or not net_connect:
        status = "SKIPPED"
        summary = "Skipped due to Phase 2 (Authentication) failure or no connection object."
        details = None
        error = phase2_result.get('error', "Authentication failed or connection not available.")
        if net_connect: # Should not happen if status is not SUCCESS, but good practice to close if it exists and we skip
            try:
                net_connect.disconnect()
                print(f"  Closed stray connection to {hostname} before skipping Phase 3.")
            except Exception as e_disc:
                print(f"  Error disconnecting stray connection for {hostname}: {e_disc}")
        log_phase_result(audit_run_id, hostname, ip_address, 3, phase_name, status, summary, details, error, start_time)
        return {"status": status, "details": details, "error": error}

    try:
        # Correctly access secret from router_config for enable mode
        enable_secret = router_config.get('secret', '')
        if net_connect.check_enable_mode() is False:
            if enable_secret:
                print(f"  Entering enable mode on {hostname}...")
                net_connect.enable()
            else:
                print(f"  Enable mode not entered on {hostname} as no secret was provided. Skipping enable-only commands or proceeding with caution.")

        # Define commands for AUX port security audit
        # These are examples; actual commands might vary based on audit depth
        commands_to_run = [
            "show line aux 0",
            "show running-config | include line aux 0",
            "show running-config | include aaa new-model", # Check if modern AAA is enabled
            "show running-config | include aaa authentication login default", # Check default login auth methods
            "show running-config | include aaa authentication login CONSOLE", # Check console specific (often AUX shares this)
            "show running-config | include username", # Look for local users
            "show running-config | include privilege exec level 0", # Check exec privilege levels
            "show ip interface brief | include AUX", # If AUX has an IP (rare, but possible)
            "show users", # See current logged-in users (might show AUX activity)
            "show version" # General device info
        ]

        print(f"  Collecting configurations from {hostname}...")
        for cmd in commands_to_run:
            print(f"    Executing: {cmd}")
            try:
                # For commands that might not exist or fail on some devices/privilege levels, 
                # use send_command_timing or add error handling per command if needed.
                # For simplicity, direct send_command is used here.
                output = net_connect.send_command(cmd, read_timeout=20) # Increased read_timeout for potentially long configs
                collected_data[cmd] = output
            except Exception as cmd_e:
                print(f"    Error executing command '{cmd}': {str(cmd_e)}")
                collected_data[cmd] = f"ERROR: {str(cmd_e)}"
        
        status = "SUCCESS"
        summary = f"Successfully collected {len(collected_data)} configurations from {hostname}."
        details = {"collected_configs": collected_data, "findings_count": 0} # Placeholder for findings
        error = ""
        print(f"  Finished collecting configurations from {hostname}.")

    except Exception as e:
        status = "FAILURE"
        summary = f"Error during configuration collection from {hostname}."
        details = {"exception_type": str(type(e).__name__)}
        error = str(e)
        print(f"  Error in Phase 3 for {hostname}: {error}")
    finally:
        # IMPORTANT: Close the connection after Phase 3 is done with it.
        if net_connect:
            try:
                net_connect.disconnect()
                print(f"  Disconnected SSH session from {hostname} after Phase 3.")
            except Exception as e_disc:
                print(f"  Error disconnecting from {hostname} after Phase 3: {e_disc}")

    log_phase_result(audit_run_id, hostname, ip_address, 3, phase_name, status, summary, details, error, start_time)
    return {"status": status, "details": details, "error": error}

# --- Phase 4: Risk Assessment ---
def execute_phase4_risk_assessment(audit_run_id, router_config, phase3_result):
    """Assesses risks based on findings from the configuration audit."""
    hostname = router_config.get('hostname')
    ip_address = router_config.get('ip')
    phase_name = "Risk Assessment"
    print(f"Starting Phase 4: {phase_name} for {hostname}")
    start_time = datetime.datetime.now()
    risks_found = []
    overall_risk_level = "LOW" # Default

    if phase3_result.get('status') != "SUCCESS":
        status = "SKIPPED"
        summary = "Skipped due to Phase 3 (Configuration Audit) failure."
        details = {"risks": [], "overall_risk": "UNKNOWN"}
        error = phase3_result.get('error', "Configuration audit failed or was skipped.")
        log_phase_result(audit_run_id, hostname, ip_address, 4, phase_name, status, summary, details, error, start_time)
        return {"status": status, "details": details, "error": error}

    collected_configs = phase3_result.get('details', {}).get('collected_configs', {})
    if not collected_configs:
        status = "FAILURE"
        summary = "No configuration data available from Phase 3 to assess risks."
        details = {"risks": [], "overall_risk": "UNKNOWN"}
        error = "Missing collected_configs in Phase 3 results."
        log_phase_result(audit_run_id, hostname, ip_address, 4, phase_name, status, summary, details, error, start_time)
        return {"status": status, "details": details, "error": error}

    # --- Perform Risk Checks ---
    # Check 1: AAA New-Model
    aaa_new_model_config = collected_configs.get("show running-config | include aaa new-model", "")
    if "aaa new-model" not in aaa_new_model_config.lower():
        risks_found.append({
            "risk_id": "RA001",
            "description": "AAA New-Model is not enabled. Legacy authentication/authorization methods may be in use, which are less secure.",
            "severity": "MEDIUM",
            "evidence": aaa_new_model_config
        })

    # Check 2: Line AUX 0 specific configuration
    line_aux_config = collected_configs.get("show line aux 0", "")
    if "no login" in line_aux_config.lower(): # This is a very direct and insecure setting
        risks_found.append({
            "risk_id": "RA002",
            "description": "Line AUX 0 is configured with 'no login', allowing access without authentication.",
            "severity": "HIGH",
            "evidence": line_aux_config
        })
    elif "login local" not in line_aux_config.lower() and "login authentication" not in line_aux_config.lower():
        # If not using 'login local' or 'login authentication <list>', it might be using default (password only) or just password.
        # This check is simplified; a more robust check would parse 'login' and 'password' lines.
        if "password" not in line_aux_config.lower(): # No explicit password and not AAA/local
             risks_found.append({
                "risk_id": "RA003",
                "description": "Line AUX 0 does not appear to have explicit 'login local', 'login authentication', or a direct password set. It may be unsecured or relying on global defaults that could be weak.",
                "severity": "MEDIUM",
                "evidence": line_aux_config
            })

    if "transport input all" in line_aux_config.lower():
        risks_found.append({
            "risk_id": "RA004",
            "description": "Line AUX 0 allows 'transport input all'. This could enable insecure protocols like Telnet if not otherwise restricted.",
            "severity": "MEDIUM",
            "evidence": line_aux_config
        })
    elif "transport input telnet" in line_aux_config.lower() or ("transport input ssh telnet" in line_aux_config.lower()):
         risks_found.append({
            "risk_id": "RA005",
            "description": "Line AUX 0 explicitly allows Telnet. Telnet is an insecure protocol.",
            "severity": "HIGH",
            "evidence": line_aux_config
        })

    # Determine overall risk level (simplified)
    if any(r['severity'] == "HIGH" for r in risks_found):
        overall_risk_level = "HIGH"
    elif any(r['severity'] == "MEDIUM" for r in risks_found):
        overall_risk_level = "MEDIUM"

    status = "SUCCESS"
    summary = f"Risk assessment completed. Found {len(risks_found)} potential risk(s). Overall risk: {overall_risk_level}."
    details = {"risks": risks_found, "overall_risk": overall_risk_level, "config_source_count": len(collected_configs)}
    error = ""

    log_phase_result(audit_run_id, hostname, ip_address, 4, phase_name, status, summary, details, error, start_time)
    return {"status": status, "details": details, "error": error}

# --- Phase 5: Reporting and Recommendations ---
def execute_phase5_reporting(audit_run_id, router_config, phase1_res, phase2_res, phase3_res, phase4_res):
    """Generates a final report and recommendations based on all audit phases."""
    hostname = router_config.get('hostname')
    ip_address = router_config.get('ip')
    phase_name = "Reporting and Recommendations"
    print(f"Starting Phase 5: {phase_name} for {hostname}")
    start_time = datetime.datetime.now()

    report_summary = f"Audit Report for {hostname} ({ip_address})\n"
    report_summary += f"Audit Run ID: {audit_run_id}\n"
    report_summary += f"Timestamp: {start_time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"

    # Summarize each phase
    report_summary += "--- Phase Summaries ---\n"
    report_summary += f"Phase 1 (Connectivity): {phase1_res.get('status')} - {(phase1_res.get('details') or {}).get('summary', 'N/A')}\n"
    report_summary += f"Phase 2 (Authentication): {phase2_res.get('status')} - {(phase2_res.get('details') or {}).get('summary', 'N/A')}\n"
    report_summary += f"Phase 3 (Config Audit): {phase3_res.get('status')} - {(phase3_res.get('details') or {}).get('summary', 'N/A')}\n"
    report_summary += f"Phase 4 (Risk Assessment): {phase4_res.get('status')} - {(phase4_res.get('details') or {}).get('summary', 'N/A')}\n"
    report_summary += f"  Overall Risk Level: {(phase4_res.get('details') or {}).get('overall_risk', 'UNKNOWN')}\n\n"

    recommendations = []
    # Ensure risks are retrieved safely if phase4_res.details is None
    risks = (phase4_res.get('details') or {}).get('risks', [])

    if not risks and phase4_res.get('status') == "SUCCESS":
        report_summary += "--- Risks Found ---\nNo significant security risks identified based on the performed checks.\n\n"
    elif risks:
        report_summary += "--- Risks Found ---\n"
        for risk in risks:
            report_summary += f"  - Risk ID: {risk.get('risk_id')}\n"
            report_summary += f"    Description: {risk.get('description')}\n"
            report_summary += f"    Severity: {risk.get('severity')}\n"
            report_summary += f"    Evidence Snippet: {str(risk.get('evidence', '')).strip()[:100]}...\n\n"

            # Generate Recommendations (Generic)
            if risk.get('risk_id') == "RA001": # AAA New-Model not enabled
                recommendations.append(
                    f"Recommendation for {risk.get('risk_id')}: Enable 'aaa new-model' globally to leverage modern AAA features for authentication, authorization, and accounting."
                )
            elif risk.get('risk_id') == "RA002": # Line AUX 0 with 'no login'
                recommendations.append(
                    f"Recommendation for {risk.get('risk_id')}: Remove 'no login' from Line AUX 0. Configure strong authentication (e.g., 'login authentication <AAA_list>' or 'login local') and a secure password if local auth is used."
                )
            elif risk.get('risk_id') == "RA003": # Line AUX 0 insecure default login
                recommendations.append(
                    f"Recommendation for {risk.get('risk_id')}: Secure Line AUX 0 by explicitly configuring 'login local' (with strong local users) or 'login authentication <AAA_list>'. If a direct password is set, ensure it is strong."
                )
            elif risk.get('risk_id') == "RA004": # Line AUX 0 transport input all
                recommendations.append(
                    f"Recommendation for {risk.get('risk_id')}: On Line AUX 0, restrict 'transport input' to only necessary protocols (e.g., 'transport input ssh'). Avoid 'transport input all'."
                )
            elif risk.get('risk_id') == "RA005": # Line AUX 0 transport input telnet
                recommendations.append(
                    f"Recommendation for {risk.get('risk_id')}: Disable Telnet on Line AUX 0 ('no transport input telnet' or restrict to 'transport input ssh'). Use SSH for secure access."
                )
    else:
        report_summary += "--- Risks Found ---\nRisk assessment was skipped or failed, so no specific risks can be listed.\n\n"


    if recommendations:
        report_summary += "--- Recommendations ---\n"
        for rec in recommendations:
            report_summary += f"- {rec}\n"
    else:
        report_summary += "--- Recommendations ---\nNo specific recommendations generated based on the findings.\n"

    status = "SUCCESS"
    summary = f"Report generated for {hostname}. Overall risk: {(phase4_res.get('details') or {}).get('overall_risk', 'UNKNOWN')}. {len(recommendations)} recommendation(s) made."
    details = {"report_text": report_summary, "recommendations_list": recommendations}
    error = ""

    # For now, we'll print the report to console. In a real tool, this might be written to a file or a more structured output.
    print("\n" + "-"*20 + f" Audit Report for {hostname} " + "-"*20)
    print(report_summary)
    print("-"* (40 + len(f" Audit Report for {hostname} ")) + "\n")

    log_phase_result(audit_run_id, hostname, ip_address, 5, phase_name, status, summary, details, error, start_time)
    return {"status": status, "details": details, "error": error}


# --- Web Interface Routes ---
@app.route('/')
def index():
    """Main page of the Phased Audit Tool web interface."""
    # Create a simple HTML response since we don't have templates
    html = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Phased Audit Tool</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            h1 { color: #2c3e50; }
            .container { max-width: 1200px; margin: 0 auto; }
            .btn { 
                display: inline-block; 
                padding: 10px 15px; 
                background-color: #3498db; 
                color: white; 
                text-decoration: none; 
                border-radius: 4px;
                margin: 10px 0;
            }
            .results { 
                margin-top: 20px; 
                border: 1px solid #ddd; 
                padding: 15px;
                border-radius: 4px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Phased Audit Tool</h1>
            <p>This tool performs a 5-phase security audit on network devices:</p>
            <ol>
                <li>Connectivity Verification</li>
                <li>Authentication Testing</li>
                <li>Configuration Audit</li>
                <li>Risk Assessment</li>
                <li>Reporting and Recommendations</li>
            </ol>
            <a href="/run-audit" class="btn">Run Audit with Sample Data</a>
            <a href="/view-results" class="btn">View Past Results</a>
            
            <div class="results" id="results">
                <h2>Results will appear here</h2>
                <p>Click "Run Audit" to start a new audit with sample data.</p>
            </div>
        </div>
    </body>
    </html>
    """
    return html

@app.route('/run-audit')
def run_audit():
    """Run the phased audit with sample data and return results."""
    # Sample router data for testing
    sample_routers = [
        {
            'hostname': 'Router1-Lab',
            'ip': '192.168.1.1',
            'username': 'admin',
            'password': 'cisco123',
            'device_type': 'cisco_ios',
            'secret': 'enable_secret',
            'port': 22
        }
    ]
    
    audit_results = perform_phased_audit(sample_routers)
    
    # Format results for display
    html_results = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Audit Results</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            h1, h2, h3 { color: #2c3e50; }
            .container { max-width: 1200px; margin: 0 auto; }
            .results { margin-top: 20px; }
            .phase { margin-left: 20px; }
            .success { color: green; }
            .failure { color: red; }
            .skipped { color: orange; }
            .back-btn {
                display: inline-block; 
                padding: 10px 15px; 
                background-color: #3498db; 
                color: white; 
                text-decoration: none; 
                border-radius: 4px;
                margin: 10px 0;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Audit Results</h1>
            <a href="/" class="back-btn">Back to Home</a>
            <div class="results">
    """
    
    for router_name, results in audit_results.items():
        html_results += f"<h2>Results for {router_name}:</h2>"
        for phase, result in results.items():
            status_class = "success" if result.get('status') == "SUCCESS" else "failure" if result.get('status') == "FAILURE" else "skipped"
            summary_text = (result.get('details') or {}).get('summary', 'No summary')
            html_results += f"<div class='phase'>"
            html_results += f"<h3>{phase.capitalize()}</h3>"
            html_results += f"<p class='{status_class}'>Status: {result.get('status')}</p>"
            html_results += f"<p>Summary: {summary_text}</p>"
            if result.get('error'):
                html_results += f"<p class='failure'>Error: {result.get('error')}</p>"
            html_results += "</div>"
    
    html_results += """
            </div>
        </div>
    </body>
    </html>
    """
    
    return html_results

@app.route('/view-results')
def view_results():
    """View past audit results from the database."""
    conn = sqlite3.connect(DATABASE_NAME)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # Get unique audit run IDs
    cursor.execute("SELECT DISTINCT audit_run_id FROM audit_phase_results ORDER BY timestamp DESC")
    audit_runs = cursor.fetchall()
    
    html = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Past Audit Results</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            h1, h2 { color: #2c3e50; }
            .container { max-width: 1200px; margin: 0 auto; }
            .audit-run { 
                margin: 20px 0; 
                padding: 15px; 
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            .phase { margin-left: 20px; }
            .success { color: green; }
            .failure { color: red; }
            .skipped { color: orange; }
            .back-btn {
                display: inline-block; 
                padding: 10px 15px; 
                background-color: #3498db; 
                color: white; 
                text-decoration: none; 
                border-radius: 4px;
                margin: 10px 0;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Past Audit Results</h1>
            <a href="/" class="back-btn">Back to Home</a>
    """
    
    if not audit_runs:
        html += "<p>No audit results found in the database.</p>"
    else:
        for audit_run in audit_runs:
            audit_run_id = audit_run['audit_run_id']
            html += f'<div class="audit-run"><h2>Audit Run: {audit_run_id}</h2>'
            
            # Get results for this audit run
            cursor.execute("""
                SELECT * FROM audit_phase_results 
                WHERE audit_run_id = ? 
                ORDER BY hostname, phase_number
            """, (audit_run_id,))
            results = cursor.fetchall()
            
            current_hostname = None
            for result in results:
                if result['hostname'] != current_hostname:
                    if current_hostname:
                        html += '</div>'  # Close previous device div
                    current_hostname = result['hostname']
                    html += f'<div class="device"><h3>Device: {current_hostname} ({result["ip_address"]})</h3>'
                
                status_class = "success" if result['status'] == "SUCCESS" else "failure" if result['status'] == "FAILURE" else "skipped"
                html += f'<div class="phase"><h4>Phase {result["phase_number"]}: {result["phase_name"]}</h4>'
                html += f'<p class="{status_class}">Status: {result["status"]}</p>'
                html += f'<p>Summary: {result["summary"]}</p>'
                if result['error']:
                    html += f'<p class="failure">Error: {result["error"]}</p>'
                html += '</div>'  # Close phase div
            
            if current_hostname:
                html += '</div>'  # Close last device div
            html += '</div>'  # Close audit run div
    
    html += """
        </div>
    </body>
    </html>
    """
    
    conn.close()
    return html

# --- Main Audit Orchestrator ---
def perform_phased_audit(routers_to_audit):
    """Orchestrates the 5-phase audit for a list of routers."""
    # Initialize database for storing phase results
    initialize_database()
    
    # Generate a unique ID for this audit run
    audit_run_id = str(uuid.uuid4())
    
    # Display audit banner
    print(f"\n{Fore.CYAN}{'='*70}{Style.RESET_ALL}")
    print(f"{Fore.CYAN}🔍 5-PHASE NETWORK SECURITY AUDIT{Style.RESET_ALL}")
    print(f"{Fore.CYAN}📊 Starting audit run ID: {audit_run_id}{Style.RESET_ALL}")
    print(f"{Fore.CYAN}{'='*70}{Style.RESET_ALL}")
    
    # SECURITY ENHANCEMENT: Prompt for user-defined master password
    master_password = prompt_for_master_password(confirm=True)
    
    # Initialize credential manager with the user's password
    cred_manager = CredentialManager(master_password)
    print(f"{Fore.GREEN}✅ Credentials will be securely encrypted using your master password{Style.RESET_ALL}")
    
    # Store results for each router
    overall_results = {}

    # Process router inventory first - ensure all credentials are encrypted
    secure_routers = []
    for router in routers_to_audit:
        # Create a copy of the router config to avoid modifying the original
        router_copy = router.copy()
        
        # Check if the password and secret need to be encrypted
        if 'password' in router_copy and router_copy['password'] and not router_copy['password'].startswith('gAAAAAB'):
            # Encrypt the password if it's not already encrypted
            router_copy['password'] = cred_manager.encrypt(router_copy['password'])
            print(f"{Fore.GREEN}✅ Encrypted credentials for {router_copy.get('hostname', 'Unknown')}{Style.RESET_ALL}")
        
        # Also encrypt enable secret if present
        if 'secret' in router_copy and router_copy['secret'] and not router_copy['secret'].startswith('gAAAAAB'):
            router_copy['secret'] = cred_manager.encrypt(router_copy['secret'])
        
        secure_routers.append(router_copy)
    
    # Now start the audit process with securely encrypted credentials
    for router_config in secure_routers:
        hostname = router_config.get('hostname', 'UnknownRouter')
        print(f"\n{Fore.CYAN}{'='*50}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}🔎 Auditing Router: {hostname}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*50}{Style.RESET_ALL}")
        router_results = {}

        # Phase 1: Connectivity Verification
        phase1_res = execute_phase1_connectivity(audit_run_id, router_config)
        router_results['phase1'] = phase1_res

        # Phase 2: Authentication Testing (pass credential manager for secure password handling)
        phase2_res = execute_phase2_authentication(audit_run_id, router_config, phase1_res, cred_manager)
        router_results['phase2'] = phase2_res

        # Phase 3: Configuration Audit
        phase3_res = execute_phase3_config_audit(audit_run_id, router_config, phase2_res) # phase2_res now contains 'connection'
        router_results['phase3'] = phase3_res

        # Phase 4: Risk Assessment
        phase4_res = execute_phase4_risk_assessment(audit_run_id, router_config, phase3_res)
        router_results['phase4'] = phase4_res

        # Phase 5: Reporting and Recommendations
        phase5_res = execute_phase5_reporting(audit_run_id, router_config, phase1_res, phase2_res, phase3_res, phase4_res)
        router_results['phase5'] = phase5_res
        
        overall_results[hostname] = router_results
        print(f"--- Finished auditing Router: {hostname} ---")

    print(f"\nPhased audit run {audit_run_id} completed.")
    # Placeholder: Add overall summary reporting here if needed
    return overall_results

# --- Logging Setup ---
LOG_FILE_NAME = "app_audit.log"

def setup_logging():
    """Configures logging to file and console."""
    abs_log_file_path = os.path.abspath(LOG_FILE_NAME)
    print(f"[DEBUG] Attempting to configure logging. Target log file: {abs_log_file_path}")

    try:
        logging.basicConfig(
            level=logging.DEBUG, # Log everything to the file
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            filename=abs_log_file_path, # Use absolute path
            filemode='a' # Append to log file
        )
        print(f"[DEBUG] logging.basicConfig called for {abs_log_file_path}")
        
        # Check if file exists immediately after basicConfig
        if os.path.exists(abs_log_file_path):
            print(f"[SUCCESS] Log file confirmed to exist after basicConfig: {abs_log_file_path}")
            logging.info("Logging configured successfully. Log file: %s", abs_log_file_path)
        else:
            print(f"[ERROR] Log file DOES NOT exist after basicConfig: {abs_log_file_path}")
            logging.error("Failed to create or access log file after basicConfig: %s", abs_log_file_path)

    except Exception as e:
        print(f"[CRITICAL] Exception during logging.basicConfig setup: {e}")
        # Fallback: print to stderr if logging setup failed catastrophically
        import sys
        sys.stderr.write(f"CRITICAL LOGGING SETUP ERROR: {e}\n")

    # Initial log message to confirm setup (will only work if basicConfig was successful)
    # logging.info("Logging configured. Log file: %s", LOG_FILE_NAME) # Moved inside try block for confirmation
    # print(f"[INFO] Logging configured. Log file: {LOG_FILE_NAME}") # Redundant if above works

# Call logging setup at the start
setup_logging() # <--- Call the setup function

if __name__ == '__main__':
    # Ensure logging is set up before anything else if not already called globally
    # setup_logging() # Already called globally, but good to keep in mind for script structure

    # Example usage:
    # Replace with actual router data, potentially loaded from CSV or other inventory source
    sample_routers = [
        {
            'hostname': 'Router1-Lab',
            'ip': '192.168.1.1',
            'username': 'admin',
            'password': 'cisco123',
            'device_type': 'cisco_ios',
            'secret': 'enable_secret',
            'port': 22
        }
    ]
    
    # Check if running as a script or as a web server
    import sys
    if len(sys.argv) > 1 and sys.argv[1] == '--cli':
        # Run in CLI mode
        print("Starting Phased Audit Tool...")
        init_database()
        audit_summary = perform_phased_audit(sample_routers)

        print("\n--- Audit Summary ---")
        for router_name, results in audit_summary.items():
            print(f"\nResults for {router_name}:")
            for phase, result in results.items():
                # Apply the same fix here for accessing summary safely
                summary_text = (result.get('details') or {}).get('summary', 'No summary')
                print(f"  {phase.capitalize()}: {result.get('status')} - {summary_text}")
                if result.get('error'):
                    print(f"    Error: {result.get('error')}")

        print("\nTo view detailed results, query the database: phased_audit_results.sqlite, table: audit_phase_results")
    else:
        # Run as web server
        print(f"Starting Phased Audit Tool Web Server on port {app.config['PORT']}...")
        init_database()
        socketio.run(app, host='0.0.0.0', port=app.config['PORT'], debug=True)

# Platform specific ping command
if platform.system().lower() == "windows":
    PING_CMD = ["ping", "-n", "1", "-w", "1000"]  # 1 packet, 1 second timeout (milliseconds for Windows)
else:
    PING_CMD = ["ping", "-c", "1", "-W", "1"]   # 1 packet, 1 second timeout (seconds for Linux/macOS)

# Placeholder for application configuration (e.g., loaded from .env or config file)
app_config: Dict[str, Any] = {
    # Placeholder for Jump Host credentials - REPLACE WITH ACTUAL, SECURE CONFIGURATION
    "JUMP_HOST": "your_jump_host_ip_or_fqdn", # e.g., "192.168.1.100"
    "JUMP_USERNAME": "your_jump_user",
    "JUMP_PASSWORD": "your_jump_password",

    # Placeholder for Target Device credentials - REPLACE WITH ACTUAL, SECURE CONFIGURATION
    "DEVICE_USERNAME": "your_device_user",
    "DEVICE_PASSWORD": "your_device_password",
    "DEVICE_ENABLE": "your_device_enable_password", # Optional
}

# --- Jump Host and Device Connection Utilities ---
{{ ... }}
def main_cli_logic():
    """Main CLI application logic - placeholder for now."""
    log_cli_message("CLI Application Started", "INFO")
    
    # Example of using the error handler
    try:
        # Simulate an error
        # x = 1 / 0 # Uncomment to test basic error handling
        # raise ValueError("A sample value error for testing advanced handler.")
        pass # No error simulated for now
    except Exception as e:
        error_details = advanced_error_handler.handle_error(e, ErrorCategory.APPLICATION, {"context": "main_cli_test"})
        log_cli_message(f"Advanced Error Handler Result: {error_details}", "ERROR")

    # Test sanitize_log_message
    sensitive_message = "User admin logged in with password secretpassword123 from 192.168.1.10"
    sensitive_strings_to_redact.extend(["admin", "secretpassword123", "192.168.1.10"])
    sanitized_message = sanitize_log_message(sensitive_message)
    log_cli_message(f"Original: {sensitive_message}", "DEBUG")
    log_cli_message(f"Sanitized: {sanitized_message}", "DEBUG")
    sensitive_strings_to_redact.clear() # Clear for other tests

    # Test log_raw_trace
    log_raw_trace("This is a raw trace message for testing.", command_type="TEST_TRACE", device="TestDevice")

    # --- Test Jump Host and Device Connection --- 
    log_cli_message("--- Starting Jump Host Connection Test ---", "INFO")
    
    # IMPORTANT: Ensure app_config has placeholder or real (for local testing) credentials.
    # For this test to actually connect, JUMP_HOST, JUMP_USERNAME, JUMP_PASSWORD must be valid.
    # And for device connection, DEVICE_USERNAME, DEVICE_PASSWORD and a target device_ip must be valid.
    
    # Update app_config with test values if you want to run a live test
    # For automated testing, these would ideally be mocked or use a test SSH server.
    # Example (replace with your actual test jump host if you have one):
    # app_config["JUMP_HOST"] = "10.0.0.1" 
    # app_config["JUMP_USERNAME"] = "testuser"
    # app_config["JUMP_PASSWORD"] = "testpass"

    jump_ssh_client = establish_jump_host_connection()
    
    if jump_ssh_client:
        log_cli_message("Jump host connection successful. Proceeding to device connection test.", "SUCCESS")
        
        # Define a dummy device for testing
        # Replace 'target_device_ip' with an actual IP reachable via your jump host for a live test.
        dummy_device_info = {
            "hostname": "TestRouterViaJump",
            "ip_address": "your_target_device_ip_via_jump", # e.g., "192.168.100.1"
            "device_type": "cisco_ios" # or other supported Netmiko type
        }
        
        # Example (replace with your actual target device IP and credentials if testing live):
        # dummy_device_info["ip_address"] = "10.0.1.1"
        # app_config["DEVICE_USERNAME"] = "device_admin"
        # app_config["DEVICE_PASSWORD"] = "device_pass"

        log_cli_message(f"Attempting to connect to device: {dummy_device_info['hostname']} ({dummy_device_info['ip_address']})", "INFO")
        device_connection = connect_to_device_via_jump_host(jump_ssh_client, dummy_device_info)
        
        if device_connection:
            log_cli_message(f"Successfully connected to {dummy_device_info['hostname']} via jump host!", "SUCCESS")
            
            # Example: Send a command (if connection object supports it - Netmiko/ParamikoWrapper)
            try:
                if hasattr(device_connection, 'send_command'):
                    # For Cisco IOS, 'show version' is a common command.
                    # For Linux (if device_type was 'linux'), 'uname -a' could be used.
                    command_to_send = "show version" if dummy_device_info["device_type"].startswith("cisco") else "uname -a"
                    log_cli_message(f"Sending command: '{command_to_send}' to {dummy_device_info['hostname']}", "INFO")
                    output = device_connection.send_command(command_to_send)
                    log_cli_message(f"Output from {dummy_device_info['hostname']}:\n{output[:500]}... (truncated)", "INFO") # Log first 500 chars
                else:
                    log_cli_message(f"Device connection object for {dummy_device_info['hostname']} does not have 'send_command' method.", "WARNING")
            except Exception as e_cmd:
                log_cli_message(f"Error sending command to {dummy_device_info['hostname']}: {sanitize_log_message(str(e_cmd))}", "ERROR")
            finally:
                # Disconnect from the device
                if hasattr(device_connection, 'disconnect'):
                    device_connection.disconnect()
                else:
                    log_cli_message(f"No disconnect method on device_connection object for {dummy_device_info['hostname']}","WARNING")
        else:
            log_cli_message(f"Failed to connect to {dummy_device_info['hostname']} via jump host.", "ERROR")
            
        # Close jump host connection
        jump_ssh_client.close()
        log_cli_message("Jump host SSH client closed.", "INFO")
    else:
        log_cli_message("Jump host connection failed. Cannot test device connection.", "ERROR")
    
    log_cli_message("--- Jump Host Connection Test Finished ---", "INFO")

    log_cli_message("CLI Application Finished", "INFO")

{{ ... }}
